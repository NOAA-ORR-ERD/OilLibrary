#!/usr/bin/env python
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from future import standard_library
standard_library.install_aliases()
from builtins import zip
from builtins import range
from builtins import *
from builtins import object
import sys
import logging

logger = logging.getLogger(__name__)


class ImportFileHeaderLengthError(Exception):
    pass


class ImportFileHeaderContentError(Exception):
    pass


class OilLibraryFile(object):
    ''' A specialized file reader for the OilLib and CustLib
        flat datafiles.
        - We will use universal newline support to designate
          a line of text.
        - Additionally, each line contains a number of fields
          separated by a tab ('\t').  In this way it attempts
          to represent tabular data.
        - The first line in the file contains a file format
          version number ('N.N'), followed by a date ('d/m/YY'),
          and finally the product ('adios').
        - The second line in the file contains a table header,
          where each field represents the "long" name of a
          tabular column.
        - The rest of the lines in the file contain table data.

    '''
    def __init__(self, name, field_delim='\t', ignore_version=False):
        '''
            :param name: The name of the oil library import file
            :type name: A path as a string or unicode

            :param field_delim='\t': The character to be used as a tabular
                                     field delimiter.
            :type field_delim: A string or unicode

            :param ignore_version=False: Ignore the exceptions generated by a
                                         failure to parse the version header
                                         in the file.
                                         Normally we want to simply fail in
                                         this case, but for diagnosing the
                                         content of new or unfamiliar import
                                         files, we can continue on in an
                                         attempt to build our object.
            :type ignore_version: Boolean
        '''
        self.name = name
        self.file_columns = None
        self.file_columns_lu = None
        self.num_columns = None

        # use binary, as we're decoding line by line.
        # NOTE: Universal linefeeds doesn't work reliably with binary
        # files should not have old style mac lineendings
        self.fileobj = open(name, 'rb')
        self.field_delim = field_delim

        self.__version__ = self.readline()
        self._check_version_hdr(ignore_version)

        self._set_table_columns()

    def _check_version_hdr(self, ignore_version):
        ''' check that the file has a proper header.
            right now we are just checking for adios
            specific fields.
        '''
        if len(self.__version__) != 3:
            if ignore_version:
                # If we failed on header length, it is likely we have a
                # missing header.  If so, we probably read the column names
                # instead.  So we need to undo our readline() if we are
                # ignoring this.
                self.__version__ = None
                self.fileobj.seek(0)
            else:
                raise ImportFileHeaderLengthError('Bad file header: did not find '
                                                  '3 fields for version!!\n'
                                                  'header: {}\n'
                                                  'file: {}'.format(self.__version__, self.name))
        elif not self.__version__[-1].startswith('adios'):
            if ignore_version:
                # If we failed on header content, we probably have a bad
                # or unexpected header, but a header nonetheless.
                pass
            else:
                raise ImportFileHeaderContentError('Bad file header: '
                                                   'did not find '
                                                   'product field!!')

    def _set_table_columns(self):
        self.file_columns = self.readline()
        self.file_columns_lu = dict(list(zip(self.file_columns,
                                        list(range(len(self.file_columns))))))
        self.num_columns = len(self.file_columns)

    def _parse_row(self, line):
        """
        parse a line in the file

        :param line: bytes object, so that we can decode here

        returns: list of unicode (str) objects, with None for empty
        """
        if not line:
            # readline() returns empty string or byte on EOF and '\n' for empty lines
            # return None for EOF
            return None

        line = line.strip()
        if line:
            # fixme: decoding one row at a time is NOT good
            #        particularly since we control the input file!
            #       and it's probably never going to be utf-8
            # should be looking for ascii forst, then macroman, then ??
            # or use chardet?
            try:
                row = line.decode('utf-8')
            except Exception:  # this should be looking for an EncodingError!
                # If we fail to encode in utf-8, then it is possible that
                # our file contains mac_roman characters of which some are
                # out-of-range.
                # This is probably about the best we can do to anticipate
                # our file contents.
                row = line.decode('mac_roman')

            # row is a unicode string now.
            row = (row.split(self.field_delim))
            row = [c.strip('"') for c in row]
            # replace empty fields with None
            row = [c if c  else None for c in row]
        else:
            row = []
        return row

    def readline(self):
        return self._parse_row(self.fileobj.readline())

    def readlines(self):
        while True:
            line = self.readline()

            if line is None:
                break
            elif len(line) > 0:
                yield line

    def rewind(self):
        self.fileobj.seek(0)
        first_line = self.readline()

        if (self.__version__ is not None and
                len(first_line) == len(self.__version__)):
            logger.debug('first line contains the version header')
            self.readline()
        elif len(first_line) == len(self.file_columns):
            # For tabular data, the number of data fields will be the same
            # as for the column names, so this check will not be able
            # to tell if the column names are missing.
            # But at this point, we have already opened the file and
            # constructed our object and performed as many reasonable checks
            # as we can.  So we just try to be consistent with that.
            logger.debug('first line contains the file column names')
        else:
            raise ImportFileHeaderLengthError('Bad file header: '
                                              'should have found either '
                                              'the version or field names '
                                              'in the first row!!')

    def export(self, filename):
        self.rewind()

        file_out = open(filename, 'w')

        if self.__version__ is not None:
            logger.debug(self.field_delim.join(self.__version__))

            file_out.write(self.field_delim.join(self.__version__))
            file_out.write('\n')

        file_out.write(self.field_delim.join(self.file_columns))
        file_out.write('\n')

        for line in self.readlines():
            line = ['' if f is None else f
                    for f in line]

            sys.stderr.write('.')
            file_out.write(self.field_delim.join(line))
            file_out.write('\n')

        file_out.close()

    def __repr__(self):
        return "<OilLibraryFile('%s')>" % (self.name)
